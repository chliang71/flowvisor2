package org.flowvisor.allocator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import org.flowvisor.classifier.FVClassifier;
import org.flowvisor.events.FVEventLoop;
import org.flowvisor.flows.FlowEntry;
import org.flowvisor.flows.FlowMap;
import org.flowvisor.flows.SliceAction;
import org.flowvisor.log.FVLog;
import org.flowvisor.log.LogLevel;
import org.flowvisor.openflow.protocol.FVMatch;
import org.flowvisor.slicer.FVSlicer;
import org.openflow.protocol.OFMessage;
import org.openflow.protocol.action.OFAction;

public class Allocator {
	//this records all slicer and classifier
	//each slicer represents a controller
	//while each classifier represents a switch
	ConcurrentHashMap<String, FVSlicer> slicerMap;
	ConcurrentHashMap<Long, FVClassifier> classifierMap;
	ConcurrentHashMap<String, SlicerMessageStats> sliceMsgStats;
	ConcurrentHashMap<Long, String> slicerDPIDNameMap;
	ConcurrentHashMap<String, String> switchSliceMap;
	
	ConcurrentHashMap<Long, String> switchControllerMap;
	
	ConcurrentHashMap<Long, String> newSwitchControllerMap;
	
	static Allocator runningInstance = null;
	static FVEventLoop loop;
	//static TimerScheduler timer;
	//////////////////////////////

//	public void startTimer() {
//		timer = new TimerScheduler();
//		new Thread(timer).start();
//	}

	public static void createAllocator(FVEventLoop eloop) {
		loop = eloop;
		if(runningInstance == null) {
			runningInstance = new Allocator();
			//runningInstance.startTimer();
		}
		FVLog.log(LogLevel.DEBUG, null, "#####Create new Allocator#####");
	}

	public ArrayList<Long> getSwitches() {
		ArrayList<Long> dpids = new ArrayList<Long>();
		for(FVClassifier fvc : classifierMap.values()) {
			dpids.add(fvc.getDPID());
		}
		return dpids;
	}
	
	private Allocator(){
		this.slicerMap = new ConcurrentHashMap<String, FVSlicer>();
		this.classifierMap = new ConcurrentHashMap<Long, FVClassifier>();
		this.sliceMsgStats = new ConcurrentHashMap<String, SlicerMessageStats>();
		this.switchSliceMap = new ConcurrentHashMap<String, String>();
		this.slicerDPIDNameMap = new ConcurrentHashMap<Long, String>();
		this.switchControllerMap = new ConcurrentHashMap<Long, String>();
		FVLog.log(LogLevel.DEBUG, null, "creating new Allocators");
	}

	public static Allocator getRunningAllocator() {
		return runningInstance;
	}

	public void incMsgCount(FVSlicer slicer, OFMessage msg) {
		SlicerMessageStats curSms;
		if(!sliceMsgStats.containsKey(slicer.getName())) {
			//new slice coming in
			curSms = new SlicerMessageStats();
			curSms.incMessageCount(msg.getType());
		} else {
			//adding to an existing slice
			curSms = sliceMsgStats.get(slicer.getName());
			curSms.incMessageCount(msg.getType());
		}
		
		String switchName = slicer.getSwitchName();
		/*
		 * 1st, this is ok because in our model, 1 switch will only be in one slice
		 * 2nd, this is useful because what we want to know is the number of packets 
		 * generated by each *switch*, not each *slicer on the switch*
		 */
		if(!this.switchSliceMap.containsKey(switchName)){
			this.switchSliceMap.put(switchName, slicer.getName());
		} else {
			//this means that, the switch used to be in another slice, 
			//so we need to merge the old one to the new one, and delete the old one
			String oldSliceName = this.switchSliceMap.get(switchName);
			if(oldSliceName.equals(slicer.getName())) {
				//still the same, do nothing
			} else {
				this.switchSliceMap.put(switchName, slicer.getName());
				SlicerMessageStats oldSms = this.sliceMsgStats.remove(oldSliceName);
				curSms.absorb(oldSms);
			}
		}
		sliceMsgStats.put(slicer.getName(), curSms);
		slicerDPIDNameMap.put(slicer.getSwitchDpid(), slicer.getName());
	}

	public void addNewSlicer(String name, FVSlicer slicer){
		if(!slicerMap.containsKey(name)) {
			FVLog.log(LogLevel.DEBUG, null, "#####Adding a new slicer " + name + "#####");
			slicerMap.put(name, slicer);
		}
	}

	public void addNewClassifier(Long dpid, FVClassifier classifier){
		if(!classifierMap.containsKey(dpid)) {
			FVLog.log(LogLevel.DEBUG, null, "#####Adding a new classifier " + dpid + "#####");
			classifierMap.put(dpid, classifier);
		}
	}

	public void assignSlicerToClassifier(String slicerName, String classifierId, Long dpid) {
		if(!switchControllerMap.containsKey(dpid)) {
			FVLog.log(LogLevel.DEBUG, null, "#####Adding a new slicer to classifer entry, s:" +
					slicerName + " c:" + classifierId + "#####");
			switchControllerMap.put(dpid, slicerName);
		}
	}

	public String getControllerBySwitch(Long dpid) {
		for(Long tdpid : switchControllerMap.keySet()) {
			FVLog.log(LogLevel.DEBUG, null, "-->" + tdpid + ":" + switchControllerMap.get(tdpid));
		}
		return switchControllerMap.get(dpid);
	}
	
	public void modifySlicer(FVClassifier fvc, Set<String> newSlices) {
		//####################################
		String ss = fvc.getDPID() + ":slices are:==========>\n";
//		for(String s : newSlices) {
//			ss += s + "\n";
//			if (s.equals("first")){
//				newSlices.remove("first");
//				newSlices.add("second");
//			}			
//		}
		String sname = newSwitchControllerMap.get(fvc.getDPID());
		String msg = "It is supposed to be " + sname;
		newSwitchControllerMap.remove(fvc.getDPID());
		FVLog.log(LogLevel.DEBUG, null, msg);
		if(newSlices.size() > 1) {
			FVLog.log(LogLevel.DEBUG, null, "PANIC----->switch has more than 1 new slices!");
		}
		newSlices.clear();
		newSlices.add(sname);
		ss += "<==================";
		FVLog.log(LogLevel.NOTE, null, ss);
		//System.out.println(ss);
	}
	
	public void checkAllSlice() {
		ArrayList<Long> classifierName = new ArrayList<Long>(classifierMap.keySet());
		for (Long s : classifierName) {
			FVLog.log(LogLevel.DEBUG, null, "Check Classifier:" + s);
			FVClassifier classifier = classifierMap.get(s);
			if (classifier.getSwitchInfo() == null) {
				FVLog.log(LogLevel.DEBUG, null, "Classifier " + classifier.getDPID() + " does not have switch info");
			} else {
				FVLog.log(LogLevel.DEBUG, null, "Classifier " + classifier.getDPID() + " flowmap change");
				/////////////////////////
				FlowMap fm = classifier.getSwitchFlowMap();
				SliceAction sliceAction;
				FVMatch match = new FVMatch();
				match.setWildcards(FVMatch.OFPFW_ALL);
				ArrayList<FlowEntry> entries = new ArrayList<FlowEntry>(fm.matches(classifier.getSwitchInfo().getDatapathId(), match));
				for (FlowEntry entry : entries) {
					for (OFAction ofAction : entry.getActionsList()) {
						sliceAction = (SliceAction) ofAction;
						String cursname = sliceAction.getSliceName();
						FVClassifier fvc = classifierMap.get(s);
						String newsname = newSwitchControllerMap.get(fvc.getDPID());
						if(!cursname.equals(newsname)) {
							String ss = "Changing slice!!!!" + cursname + "--->" + newsname;
							FVLog.log(LogLevel.DEBUG, null, ss);
							sliceAction.setSliceName(newsname);
						}
					}
				}
//				for (FlowEntry entry : entries) {
//					for (OFAction ofAction : entry.getActionsList()) {
//						sliceAction = (SliceAction) ofAction;
//						if(sliceAction.getSliceName().equals("first")) {
//							sliceAction.setSliceName("second");
//							FVLog.log(LogLevel.DEBUG, null, "######change slice!!!#######");
//						}
//					}
//				}
				classifier.flowMapChanged(fm);
				/////////////////////////
				//classifier.flowMapChanged(null);
			}
		}
	}
//
//	class TimerScheduler implements Runnable {
//
//		@Override
//		public void run() {
//			int count = 1;
//			try {
//				while(true) {
//					Thread.sleep(5000);
//					FVLog.log(LogLevel.DEBUG, null, "#####Timer Scheduler Waked Up " + (count++) + "#####");
//					FVLog.log(LogLevel.DEBUG, null, getSliceMessageStats());					FVLog.log(LogLevel.DEBUG, null, "#####Check Slices#####");
//					checkAllSlice();
//				}
//			} catch (InterruptedException e) {
//				e.printStackTrace();
//				FVLog.log(LogLevel.DEBUG, null, "#####Allocator Interrupted#####");
//			}
//		}
//	}
	public ArrayList<String> getSliceName() {
		ArrayList<String> nameList = new ArrayList<String>(slicerMap.keySet());
		return nameList;
	}
	
	public SlicerMessageStats getSwitchStatsByDPID(Long dpid) {
		FVLog.log(LogLevel.DEBUG, null, "map####dpid:" + dpid);
		String name = slicerDPIDNameMap.get(dpid);
		FVLog.log(LogLevel.DEBUG, null, "map####name:" + name);
		return sliceMsgStats.get(name);
	}
	
	public void setNewMapping(HashMap<Long, String> map) {
		newSwitchControllerMap = new ConcurrentHashMap<>(map);
	}

}
